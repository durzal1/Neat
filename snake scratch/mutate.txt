            for node1 in self.nodes:
                if node1.type == 3 or node1.type == 4:
                    continue
                for node2 in self.nodes:
                    if node2 == node1 or node1.layer == node2.layer:
                        continue
                    connection_name = f"{node1.innovation_number}_{node2.innovation_number}"
                    for connection in self.connections:
                        gene_to = connection.gene_to
                        gene_from = connection.gene_from
                        name1 = f"{gene_to}_{gene_from}"
                        name2 = f"{gene_from}_{gene_to}"
                        if connection_name != name1 and connection_name != name2:
                            innovation_number = self.system.set_inno_number(gene_from, gene_to)
                            weight = random.uniform(-1, 1)
                            self.connections.append( ConnectionGene(innovation_number, node1.innovation_number, node2.innovation_number, True, weight, 8))
                            return None
len1 = len(self.nodes)
            connectionMade = False
            while not(connectionMade):
                ran_num = random.randint(0,len1 - 1)
                if self.nodes[ran_num - 1].type == 1 or self.nodes[ran_num - 1].type == 2:
                    for connection in self.connections:
                        gene_from = connection.gene_from
                        gene_to = connection.gene_to
                        active = connection.is_enabled
                        if gene_from == ran_num and self.nodes[gene_to - 1].type == 3 and active:
                            connection.is_enabled = False
                            self.inno_number += 1
                            self.nodes.append(Gene(2, self.inno_number, 0, self.layer))
                            og_weight = connection.weight
                            gene_from1 = gene_from
                            gene_to1 = self.inno_number
                            gene_from2 = gene_to1
                            gene_to2 = connection.gene_to
                            innovation_number = self.system.set_inno_number(gene_from1, gene_to1)
                            self.connections.append(ConnectionGene(innovation_number, gene_from1, gene_to1, True, 1, 0))
                            innovation_number1 = self.system.set_inno_number(gene_from2, gene_to2)
                            self.connections.append(ConnectionGene(innovation_number1, gene_from2, gene_to2, True, og_weight, 0))
                            self.node_num += 1
                            if self.node_num > self.inputs:
                                self.node_num = 0
                                self.layer += 1
                            connectionMade = True

MUTATES ONLY ONE CONNECTION GENE WEIGHT AT A TIME

len1 = len(self.connections)
                if len1 == 1:
                    ran_num = 0
                    mult_num = self.random_val()
                    num = (mult_num * WEIGHT_SHIFT_STRENGTH)
                    add_ = self.connections[ran_num].weight + num
                    if add_ >= 8 or add_ <= -8:  # cap of 2, -2
                        pass
                    else:
                        self.connections[ran_num].weight = add_
                if len1 > 1:
                    ran_num = random.randint(0, len1 - 1)
                    # gets age of gene_from to get weight_shift_stregth
                    # older the gene the less it should be changed because theoretically it should be better
                    # age = self.age
                    # val = 70 * (0.96) ** age
                    # WEIGHT_SHIFT_STRENGTH = val / 100
                    # changes the value of a weight by adding it to a random val
                    mult_num = self.random_val()
                    num = (mult_num * WEIGHT_SHIFT_STRENGTH)
                    add_ = self.connections[ran_num].weight + num
                    if add_ >= 8 or add_ <= -8: # cap of 2, -2
                        pass
                    else:
                        self.connections[ran_num].weight = add_
 len1 = len(self.connections)
                if len1 == 1:
                    ran_num = 0
                        # changes the value completely between -2, 2
                    new_num = self.random_val()
                    self.connections[ran_num].weight = new_num
                elif len1 > 1:
                    ran_num = random.randint(0, len1 - 1)
                        # changes the value completely between -2, 2
                    new_num = self.random_val()
                    self.connections[ran_num].weight = new_num
MUTATE ONLY ONE CONNECTION AT A TIME BIAS
len1 = len(self.nodes)
                if len1 > 1:
                    ran_num = random.randint(0, len1 - 1)
                    if self.nodes[ran_num].type == 1:
                        return None
                        # changes the value completely between -2, 2
                    new_num = self.random_val()
                    self.nodes[ran_num].bias = new_num
len1 = len(self.nodes)
                if len1 > 1:
                    ran_num = random.randint(0, len1 - 1)
                    if self.nodes[ran_num].type == 1:
                        return None
                    mult_num = self.random_val()
                    num = (mult_num * WEIGHT_SHIFT_STRENGTH)
                    add_ = self.nodes[ran_num].bias + num
                    if add_ >= 8 or add_ <= -8: # cap of 2, -2
                        pass
                    else:
                        self.nodes[ran_num].bias = add_