# for i in range(self.inputs):
        #     for a in range(self.outputs):  ##connections
        #         gene_from = i + 1
        #         gene_to = self.inputs + a + 1
        #         weight = self.random_val()
        #         innovation_number = self.system.set_inno_number(gene_from, gene_to)
        #         self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, gene_to))
        # adds bias
        self.inno_number += 1
        self.nodes.append(Gene(4, self.inno_number, 1, self.layer))
        self.layer += 1
        # connection between bias and output
        for i in range(self.outputs):
            gene_from = self.outputs + self.inputs + 1
            gene_to = self.inputs + i + 1
            weight = self.random_val()
            innovation_number = self.system.set_inno_number(gene_from, gene_to)
            self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, gene_to))

        def bias_mutate_link():
            for i in range(len(self.nodes)):
                if self.nodes[i].type == 2:
                    gene_from = self.nodes[self.inputs + self.outputs].innovation_number
                    gene_to = self.nodes[i].innovation_number
                    works = True
                    for q in range(len(self.connections)):
                        innovation_number = self.system.set_inno_number(gene_from, gene_to)
                        t = self.connections[q].innovation_number
                        if innovation_number == t:
                            works = False
                    if works:
                        innovation_number = self.system.set_inno_number(gene_from, gene_to)
                        weight = self.random_val()
                        self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, 8))
                        return None

CALCULATION STUFF I GOT RID OF
        for node in self.nodes:
            if node.type == 2:
                node.sigmoid_value = sigmoid(node.value)
            ###node value is the unsigmoided vaule
        # checks what last layer is
        # layers = []
        # for i in range(len(self.nodes)):
        #     layers.append(self.nodes[i].layer)
        # max_layer = max(layers)
        # gets output by adding all of last layer nodes' values
       
# for i in range(self.inputs):
        #     for a in range(self.outputs):  ##connections
        #         gene_from = i + 1
        #         gene_to = self.inputs + a + 1
        #         weight = self.random_val()
        #         innovation_number = self.system.set_inno_number(gene_from, gene_to)
        #         self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, gene_to))
        # adds bias
        self.inno_number += 1
        self.nodes.append(Gene(4, self.inno_number, 1, self.layer))
        self.layer += 1
        # connection between bias and output
        for i in range(self.outputs):
            gene_from = self.outputs + self.inputs + 1
            gene_to = self.inputs + i + 1
            weight = self.random_val()
            innovation_number = self.system.set_inno_number(gene_from, gene_to)
            self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, gene_to))

        def bias_mutate_link():
            for i in range(len(self.nodes)):
                if self.nodes[i].type == 2:
                    gene_from = self.nodes[self.inputs + self.outputs].innovation_number
                    gene_to = self.nodes[i].innovation_number
                    works = True
                    for q in range(len(self.connections)):
                        innovation_number = self.system.set_inno_number(gene_from, gene_to)
                        t = self.connections[q].innovation_number
                        if innovation_number == t:
                            works = False
                    if works:
                        innovation_number = self.system.set_inno_number(gene_from, gene_to)
                        weight = self.random_val()
                        self.connections.append(ConnectionGene(innovation_number, gene_from, gene_to, True, weight, 8))
                        return None

